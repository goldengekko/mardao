package ${daoPackage};

import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;

import net.sf.mardao.api.dao.CursorIterable;

import ${entity.className};

/**
 * Business Methods interface for entity ${entity.simpleName}.
 * This interface is generated by mardao, but edited by developers.
 * It is not overwritten by the generator once it exists.
 *
 * Generated on ${currentDate}.
 * @author mardao DAO generator (${helper.class.name})
 */
public interface Generated${entity.simpleName}DaoAndroid {

    /**
     * Queries the database and returns a CursorIterable of all ${entity.simpleName}s
     * @return a CursorIterable of all ${entity.simpleName}s
     */
    CursorIterable<${entity.simpleName}> queryAll();
	
    /**
	 * @return a CursorIterable of ${entity.simpleName}s
	 * @since 1.24
	 */
    CursorIterable<${entity.simpleName}> queryByPrimaryKeys(Iterable<Long> primaryKeys);
		
    // ----------------------- field finders -------------------------------
#foreach( $field in $entity.fields )

#if( $entity.isUnique($field.name) )
    // ${field.name} is unique, so use findBy${helper.firstToUpper($field.name)}(${field.type} ${field.name}) method instead
#else
    /**
     * query method for attribute field ${field.name}
     * @param ${field.name} the specified attribute
     * @return a CursorIterable of ${entity.simpleName}s with the specified attribute
     */
    CursorIterable<${entity.simpleName}> queryBy${helper.firstToUpper($field.name)}(${field.type} ${field.name});

    /**
     * query-primary-key-by method for attribute field ${field.name}
     * @param ${field.name} the specified attribute
     * @return a CursorIterable of keys to the ${entity.simpleName}s with the specified attribute
     */
    Cursor queryKeysBy${helper.firstToUpper($field.name)}(${field.type} ${field.name});
#end	
#end	
		  
	// ----------------------- uniqueFields populate -------------------------
#foreach( $uniqueFields in $entity.uniqueFieldsSets )
	/**
	 * populate method for unique attributes
#foreach( $field in $uniqueFields )	 
	 * @param ${field.name} the specified ${field.name}
#end	 
	 * @return the unique ${entity.simpleName} for the specified fields
	 */
	${entity.simpleName} populate(#foreach( $field in $uniqueFields )
${field.type} ${field.name}#if( $velocityCount < $uniqueFields.size() ), #end
#end);
#end

	// ----------------------- many-to-many updates -------------------------
#foreach( $field in $entity.manyToManys )
#if( $entities.get($field.type) )  
#set( $foreign = $entities.get($field.type))
	/**
	 * update method for many-to-many field ${field.name} related to foreign Entity ${field.simpleType}
#if( $field.mappedBy )		 
	 * This is inverse side (mappedBy="${field.mappedBy}")
#else
	 * This is owning side
#end
	 * @param ${field.name} the related ${field.type} entity
	 */
	void update${helper.firstToUpper($field.name)}(final Long ${entity.pk.name},
            final Iterable<Long> ${field.name}Ids);
#end	
	
#end

}
