package ${daoBasePackage};

import java.io.Serializable;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.apache.log4j.Logger;
import org.springframework.jdbc.core.JdbcOperations;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;
import org.springframework.jdbc.core.simple.SimpleJdbcTemplate;
import org.springframework.jdbc.support.incrementer.DataFieldMaxValueIncrementer;

public abstract class AbstractSpringHelper<T, ID extends Serializable>  implements AbstractHelper<T, ID> {

   protected final Class<T> persistentClass;
	/** the Spring SimpleJDBC template */
	protected SimpleJdbcTemplate template;
	
	/** Spring inserter */
	protected SimpleJdbcInsert insert;
	
	/** Used to generate unique ids */
	protected DataFieldMaxValueIncrementer incrementer;
	
	/** Log4j Logger */
	protected final Logger LOGGER = Logger.getLogger(getClass());

   public AbstractSpringHelper(Class<T> type) {
      this.persistentClass = type;
   }
   
   protected abstract String getTableName();
   protected abstract RowMapper<T> getRowMapper();   
   
	/**
	 * Used for test purposes and for creating tables on-deploy
	 */
	public JdbcOperations getJdbcOperations()
	{
		return template.getJdbcOperations();
	}
	
	/**
	 * Used for MaxValueIncrementer injection
	 * @param maxValueIncrementer the DataFieldMaxValueIncrementer to inject
	 */
	public void setMaxValueIncrementer(DataFieldMaxValueIncrementer maxValueIncrementer)	
	{
		incrementer = maxValueIncrementer;
	}
	
   
   /**
    * Override to implement specific EntityManager factory functionality
    * @see getEntityManager
    */
   public void close() {
#if( $containerManagedEntityManager )
      // As the EntityManager is managed by the Container,
      // we should do nothing here.
      // This setting is controlled by generator plugin configuration <containerManagedEntityManager>.
#else
      // close?
#end      
	}   

   protected Class<T> getPersistentClass() {
      return persistentClass;
   }
   
   // ------ GenericDao implementation -----------------------------

   public T findByPrimaryKey(ID id) {
   		// TODO: implement
      //final EntityManager em = getEntityManager();
      final T returnValue = null; //em.find(persistentClass, id);
      //close();
      return returnValue;
   }

   public void persist(T entity) {
   		// TODO: implement
      //final EntityManager em = getEntityManager();
      //final EntityTransaction tx = beginTransaction();
      //em.persist(entity);
      //commitTransaction(tx);
      //close();
   }

   public void update(T entity) {
   		// TODO: implement
      //final EntityManager em = getEntityManager();
      //final EntityTransaction tx = beginTransaction();
      //em.merge(entity);
      //commitTransaction(tx);
      //close();
   }

   public void delete(T entity) {
   		// TODO: implement
//      final EntityManager em = getEntityManager();
//      final EntityTransaction tx = beginTransaction();
//      em.remove(entity);
//      commitTransaction(tx);
//      close();
   }

   public List<T> findAll() {
		LOGGER.debug("findAll()");

		final String sql = "SELECT * FROM " + getTableName();
		return template.query(sql, getRowMapper());
   }
   
   // ------ AbstractHelper implementation -----------------------------

	/**
	 * find-by method for generic unique attribute field 
	 * @param fieldName the generic unique attribute's field name
	 * @param param the generic unique attribute
	 * @return the unique entity for the specified attribute
	 */
	// @SuppressWarnings("unchecked")
	public final T findUniqueBy(String fieldName, Object param) {
		// TODO: implement
		//try {
		//    final EntityManager em = getEntityManager();
		//	final Query query =	em.createQuery("SELECT t FROM " + persistentClass.getName() + " t WHERE t." + fieldName + " = :param");
		//	query.setParameter("param", param);
		//	final T returnValue = (T) query.getSingleResult();
		//	return returnValue;
		//}
		//catch (javax.persistence.NoResultException nre) {
		//}
		//finally {
		//	close();
		//}
		return null;
	}
	
	/**
	 * find-by method for generic attribute field
	 * @param fieldName the generic unique attribute's field name
	 * @param param the specified generic attribute
	 * @return a List of entities with the specified attribute
	 */
	//@SuppressWarnings("unchecked")
	public final List<T> findBy(String fieldName, Object param) {
		// TODO: implement
	    //final EntityManager em = getEntityManager();
		//final Query query =	em.createQuery("SELECT t FROM " + persistentClass.getName() + " t WHERE t." + fieldName + " = :param");
		//query.setParameter("param", param);
		final List<T> returnValue = null; // query.getResultList();
		
		// Do this so we can eager load the list and close the EM: 
		//returnValue.size();
		
		//close();
		return returnValue;
	}
	
	/**
	 * find-by method for generic field
	 * @param fieldName the generic unique attribute's field name
	 * @param foreignClass the related entity's class
	 * @param key the specified foreign key
	 * @return a List of entities with the specified foreign key
	 */
	//@SuppressWarnings("unchecked")
	public final List<T> findByKey(String fieldName, Class foreignClass, Object key) {
		// TODO: implement
	    //final EntityManager em = getEntityManager();
		//final Object lazy = em.getReference(foreignClass, key);
		final List<T> returnValue = null; // findBy(fieldName, lazy);
		
		// Do this so we can eager load the list and close the EM: 
		//returnValue.size();
		
		//close();
		return returnValue;
	}
   
	/**
	 * find-by method for unique attributes
	 * @param args the specified attribute name-value map
	 * @return the unique entity for the specified attributes
	 */
	//@SuppressWarnings("unchecked")
	public final T findBy(Map<String,Object> args) {
		// TODO: implement
	    //final EntityManager em = getEntityManager();
	    //final StringBuffer ql = new StringBuffer("SELECT t FROM ");
	    //ql.append(persistentClass.getName());
	    //ql.append(" t");
	    //boolean isFirst = true;
	    //for (Entry<String,Object> entry : args.entrySet()) {
	    //	ql.append(isFirst ? " WHERE t." : " AND t.");
	    //	isFirst = false;
	    //	ql.append(entry.getKey());
	    //	ql.append(" = :pP");
	    //	ql.append(entry.getKey());
	    //}
		//final Query query =	em.createQuery(ql.toString());
	    //for (Entry<String,Object> entry : args.entrySet()) {
	    //	query.setParameter("pP" + entry.getKey(), entry.getValue());
	    //}
		final T returnValue = null; //(T) query.getSingleResult();
		//close();
		return returnValue;
	}

	/**
	 * find-by method for unique attributes
	 * @param args the specified attribute name-value map
	 * @param orderBy the attribute to order by
	 * @param ascending true if ascending
	 * @return the unique entity for the specified attributes
	 */
	//@SuppressWarnings("unchecked")
	public List<T> findBy(Map<String,Object> args, String orderBy, boolean ascending) {
		// TODO: implement
	    //final EntityManager em = getEntityManager();
	    //final StringBuffer ql = new StringBuffer("SELECT t FROM ");
	    //ql.append(persistentClass.getName());
	    //ql.append(" t");
	    //boolean isFirst = true;
	    //for (Entry<String,Object> entry : args.entrySet()) {
	    //	ql.append(isFirst ? " WHERE t." : " AND t.");
	    //	isFirst = false;
	    //	ql.append(entry.getKey());
	    //	ql.append(" = :pP");
	    //	ql.append(entry.getKey());
	    //}
	    
	    //ql.append(" ORDER BY t.");
	    //ql.append(orderBy);
	    //ql.append(ascending ? " ASC" : " DESC");
	    
		//final Query query =	em.createQuery(ql.toString());
	    //for (Entry<String,Object> entry : args.entrySet()) {
	    //	query.setParameter("pP" + entry.getKey(), entry.getValue());
	    //}
		final List<T> returnValue = null; //query.getResultList();
		
		// Do this so we can eager load the list and close the EM: 
		//returnValue.size();
		
		//close();
		return returnValue;
	}
	
	/**
	 * find-by method for many-to-many fields
	 * @param primaryKeyName name of this entity class' primary key, e.g. "id"
	 * @param fieldName name of this side's column in the join table
	 * @param foreignSimpleClass name of the related entity class (simple name) e.g. "role"
	 * @param foreignFieldName name of the related side's column in the join table
	 * @param foreignId the related entity's primary key value
	 * @return a List of entities belonging to the many-to-many relation
	 */
	//@SuppressWarnings("unchecked")
	public final List<T> findByManyToMany(String primaryKeyName, 
			String fieldName, 
			String foreignSimpleClass, String foreignFieldName, Object foreignId) {
		// TODO: implement
	    //final EntityManager em = getEntityManager();
		//final Query keyQuery =	em.createQuery("SELECT t." + fieldName + 
		//	" FROM " + persistentClass.getName() + "_" + foreignSimpleClass +  
		//		" t WHERE t." + foreignFieldName + " = :param");
		//keyQuery.setParameter("param", foreignId);
		//final List<ID> keyList = keyQuery.getResultList();
		
		//final Query query = em.createQuery("SELECT t FROM " + persistentClass.getName() + 
		//	" t WHERE t." + primaryKeyName + " IN :param");
		//query.setParameter("param", keyList);
		final List<T> returnValue = null; //query.getResultList();
		
		// Do this so we can eager load the list and close the EM: 
		//returnValue.size();
		
		//close();
		return returnValue;
	}
		
}
