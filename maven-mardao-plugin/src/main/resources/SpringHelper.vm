package ${daoBasePackage};

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.sql.DataSource;

import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.simple.ParameterizedRowMapper;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;
import org.springframework.jdbc.core.simple.SimpleJdbcTemplate;

import ${entity.className};
#foreach( $field in $entity.manyToOnes )
import ${field.entity.className};
#end
/**
 * Concrete class without generics, for Spring container instatiation.
 */
public class ${entity.simpleName}SpringHelper extends AbstractSpringHelper<${entity.simpleName}, ${entity.pk.type}> {

	/** Table name for ${entity.simpleName} is "${entity.simpleName}" */
	public static final String TABLE_NAME = "${entity.simpleName}";

	/** Column name for primary key attribute is "${entity.pk.name}" */
	public static final String COLUMN_NAME_${entity.pk.name.toUpperCase()} = "${entity.pk.name}";

#foreach( $field in $entity.allFields )
	/** Column name for attribute ${field.name} is "${field.name}" */
	public static final String COLUMN_NAME_${field.name.toUpperCase()} = "${field.name}";
#end

	private static final String[] COLUMN_NAMES_S = {
		#foreach( $field in $entity.allFields )COLUMN_NAME_${field.name.toUpperCase()}, #end};
	/** The list of attribute names */
	public static final List<String> COLUMN_NAMES = Arrays.asList(COLUMN_NAMES_S);

	/** Default constructor */
   public ${entity.simpleName}SpringHelper() {
      super(${entity.simpleName}.class);
   }
   
	/** 
	 * Used for DataSource injection
	 * @param dataSource the DataSource to inject
	 */
	public void setDataSource(DataSource dataSource) {
		LOGGER.info("setDataSource " + dataSource);
		template = new SimpleJdbcTemplate(dataSource);
	
      // create the JDBC insert with specific columns and table name:
		insert = new SimpleJdbcInsert(dataSource)
			.withTableName(getTableName())
			.usingColumns(COLUMN_NAME_${entity.pk.name.toUpperCase()}#foreach( $field in $entity.fields )
, COLUMN_NAME_${field.name.toUpperCase()}#end
#foreach( $field in $entity.manyToOnes )
, COLUMN_NAME_${field.name.toUpperCase()}#end);
   }
   
   @Override
   protected String getTableName() {
   		return TABLE_NAME;
   }
   
   @Override
   protected String getPrimaryKeyColumnName() {
   		return COLUMN_NAME_${entity.pk.name.toUpperCase()};
   }
   
   @Override
   protected List<String> getColumnNames() {
        return COLUMN_NAMES;
   }
   
	/** Mapper for the ${entity.simpleName} row retrieval */
	private static final ParameterizedRowMapper<${entity.simpleName}> MAPPER = 
		new ParameterizedRowMapper<${entity.simpleName}>() {
		public ${entity.simpleName} mapRow(ResultSet rs, int rowNum) throws SQLException {
			final ${entity.simpleName} entity = new ${entity.simpleName}();
#set( $field = $entity.pk )
			entity.set${helper.firstToUpper($field.name)}(rs.get${helper.firstToUpper($field.simpleType)}("${field.name}"));
#foreach( $field in $entity.fields )
			entity.set${helper.firstToUpper($field.name)}(rs.get${helper.firstToUpper($field.simpleType)}("${field.name}"));
#end			
#foreach( $field in $entity.manyToOnes )

			// many-to-one ${field.name}:
			final ${field.entity.simpleName} ${field.name} = new ${field.entity.simpleName}();
			${field.name}.set${helper.firstToUpper($field.entity.pk.name)}(rs.get${helper.firstToUpper($field.entity.pk.simpleType)}("${field.name}"));
			entity.set${helper.firstToUpper($field.name)}(${field.name});
#end

			return entity;			
		}
	};
	protected final ParameterizedRowMapper<${entity.simpleName}> getRowMapper() {
		return MAPPER;
	}
	
   // ------ GenericDao implementation -----------------------------

	/**
	 * Inserts a ${entity.simpleName} instance. The primary key attribute of the instance is updated.
	 *
	 * @param entity the ${entity.simpleName} entity to insert
	 */
   @Override
   public void persist(${entity.simpleName} entity) {
		LOGGER.debug("insert(" + entity + ")");
		
		// get id from next in sequence:
		final long id = incrementer.nextLongValue();
		entity.set${helper.firstToUpper(${entity.pk.name})}(id);
		
		HashMap<String,Object> parameters = new HashMap<String,Object>();
		parameters.put(getPrimaryKeyColumnName(), id);
		
		// properties
#foreach( $field in $entity.fields )
		parameters.put(COLUMN_NAME_${field.name.toUpperCase()}, entity.get${helper.firstToUpper($field.name)}());
#end

		// foreign keys:
#foreach( $field in $entity.manyToOnes )
		final ${field.type} ${field.name} = entity.get${helper.firstToUpper($field.name)}();
		if (null != ${field.name}) {
			parameters.put(COLUMN_NAME_${field.name.toUpperCase()}, toForeignKey(${field.name}.get${helper.firstToUpper($field.entity.pk.name)}()));
		}
#end

		insert.execute(parameters);
   }
   
	public ${entity.simpleName} persist(Map<String,Object> nameValuePairs) {
		if (!getColumnNames().containsAll(nameValuePairs.keySet()))
		{
			throw new IllegalArgumentException("No such column for persist.");
		}
		LOGGER.debug("insert(" + nameValuePairs + ")");
		final ${entity.simpleName} entity = new ${entity.simpleName}();
		
		// get id from next in sequence:
		final long id = incrementer.nextLongValue();
		entity.set${helper.firstToUpper(${entity.pk.name})}(id);
		nameValuePairs.put(getPrimaryKeyColumnName(), id);
		
		// properties
#foreach( $field in $entity.fields )
		entity.set${helper.firstToUpper($field.name)}((${field.type}) nameValuePairs.get(COLUMN_NAME_${field.name.toUpperCase()}));
#end

		// foreign keys:
#foreach( $field in $entity.manyToOnes )
		Object ${field.name}Value = nameValuePairs.get(COLUMN_NAME_${field.name.toUpperCase()});
		// replace entity with its primary key
		if (${field.name}Value instanceof ${field.type}) {
			final ${field.type} ${field.name} = (${field.type}) ${field.name}Value;
			${field.name}Value = ${field.name}.get${helper.firstToUpper($field.entity.pk.name)}();
		}
		entity.set${helper.firstToUpper($field.name)}((${field.type}) ${field.name}Value);
#end

		insert.execute(nameValuePairs);
		return entity;
	}
   

	/** UPDATE SQL String for ${entity.simpleName} updates. */
	protected static final String SQL_UPDATE = "UPDATE " + TABLE_NAME + " SET " + 
    		// attributes first:
#foreach( $field in $entity.fields )
			COLUMN_NAME_${field.name.toUpperCase()} + " = ?#if( 0 < $entity.manyToOnes.size() || $velocityCount < $entity.fields.size() ), #end" + 
#end

			// then many-to-ones:
#foreach( $field in $entity.manyToOnes )
			COLUMN_NAME_${field.name.toUpperCase()} + " = ?#if( $velocityCount < $entity.manyToOnes.size() ), #end" + 
#end

			// finally, the primary key for WHERE clause:
			" WHERE " + COLUMN_NAME_${entity.pk.name.toUpperCase()} + " = ?";

	/**
	 * Updates a ${entity.simpleName} instance. 
	 * The primary key must not be changed.
	 *
	 * @param entity the instance to update
	 */
    public void update(final ${entity.simpleName} entity) {
		LOGGER.debug("update(" + entity + ")");
		
		// attributes first:
		final Object args[] = {
#foreach( $field in $entity.fields )
			entity.get${helper.firstToUpper($field.name)}(), 
#end

			// then many-to-ones:
#foreach( $field in $entity.manyToOnes )
			toForeignKey(entity.get${helper.firstToUpper($field.name)}()), 
#end

			// finally, the primary key for WHERE clause:
			entity.get${helper.firstToUpper($entity.pk.name)}()};
		template.update(SQL_UPDATE, args);
	}
	
   public void delete(${entity.simpleName} entity) {
		LOGGER.debug("delete(" + entity + ")");
		
		final String sql = "DELETE FROM " + TABLE_NAME + " WHERE " + COLUMN_NAME_${entity.pk.name.toUpperCase()} + " = ?";
		int affected = template.update(sql, entity.get${helper.firstToUpper($field.name)}());
		if (0 == affected)
		{
			throw new EmptyResultDataAccessException("No such " + getTableName() + " for id " + entity.get${helper.firstToUpper($field.name)}(), 1);
		}
   }

}
